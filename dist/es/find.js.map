{"version":3,"sources":["../../src/find.ts"],"names":["require","filterInMemoryFields","find","db","collectionName","query","metaDB","getAllFromIndex","IDBKeyRange","bound","name","indexedCols","translatedSelector","rows","store","transaction","field","queryOpts","keyRange","index","openCursor","cursor","getRows","limit","inMemoryFields","length","map","row","doc","Infinity","i","push","value"],"mappings":";;;;;;;;;;;;;AAEA;;AACA;;AACA;;AACA,eAAiCA,OAAO,CAAC,uBAAD,CAAxC;AAAA,IAAQC,oBAAR,YAAQA,oBAAR;;AAEO,IAAMC,IAAI;AAAA,2FAAG,iBAClBC,EADkB,EAElBC,cAFkB,EAGlBC,KAHkB;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAKG,+BALH;;AAAA;AAKZC,YAAAA,MALY;AAAA;AAAA,mBAMQA,MAAM,CAACC,eAAP,CACxB,aADwB,EAExB,kBAFwB,EAGxBC,WAAW,CAACC,KAAZ,CAAkB,CAACN,EAAE,CAACO,IAAJ,EAAUN,cAAV,CAAlB,EAA6C,CAACD,EAAE,CAACO,IAAJ,EAAUN,cAAV,CAA7C,CAHwB,CANR;;AAAA;AAMZO,YAAAA,WANY;AAWZC,YAAAA,kBAXY,GAWS,mCAA4BP,KAA5B,EAAmCM,WAAnC,CAXT;AAadE,YAAAA,IAbc,GAaP,EAbO;AAcZC,YAAAA,KAdY,GAcJX,EAAE,CAACY,WAAH,CAAeX,cAAf,EAA+BU,KAd3B;;AAAA,kBAedF,kBAAkB,CAACI,KAAnB,IAA4BJ,kBAAkB,CAACK,SAfjC;AAAA;AAAA;AAAA;;AAgBVC,YAAAA,QAhBU,GAgBC,mCAAiBN,kBAAkB,CAACK,SAApC,CAhBD;AAiBVE,YAAAA,KAjBU,GAiBFL,KAAK,CAACK,KAAN,CAAYP,kBAAkB,CAACI,KAA/B,CAjBE;AAAA;AAAA,mBAkBKG,KAAK,CAACC,UAAN,CAAiBF,QAAjB,CAlBL;;AAAA;AAkBVG,YAAAA,MAlBU;AAAA;AAAA,mBAmBHC,OAAO,CAACD,MAAD,EAAShB,KAAK,CAACkB,KAAf,CAnBJ;;AAAA;AAmBhBV,YAAAA,IAnBgB;AAAA;AAAA;;AAAA;AAAA;AAAA,mBAqBKC,KAAK,CAACM,UAAN,EArBL;;AAAA;AAqBVC,YAAAA,OArBU;AAAA;AAAA,mBAsBHC,OAAO,CAACD,OAAD,EAAShB,KAAK,CAACkB,KAAf,CAtBJ;;AAAA;AAsBhBV,YAAAA,IAtBgB;;AAAA;AAyBlB,gBAAID,kBAAkB,CAACY,cAAnB,CAAkCC,MAAtC,EAA8C;AAC5CZ,cAAAA,IAAI,GAAGZ,oBAAoB,CACzBY,IAAI,CAACa,GAAL,CAAS,UAACC,GAAD,EAAS;AAChB;AACA;AACA,uBAAO;AAAEC,kBAAAA,GAAG,EAAED;AAAP,iBAAP;AACD,eAJD,CADyB,EAMzBtB,KANyB,EAOzBO,kBAAkB,CAACY,cAPM,CAA3B;AASD;;AAnCiB,6CAqCXX,IArCW;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAH;;AAAA,kBAAJX,IAAI;AAAA;AAAA;AAAA,GAAV;;;;AAwCP,IAAMoB,OAAO;AAAA,4FAAG,kBACdD,MADc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEdE,YAAAA,KAFc,8DAENM,QAFM;AAIRhB,YAAAA,IAJQ,GAID,EAJC;AAKViB,YAAAA,CALU,GAKN,CALM;;AAAA;AAAA,kBAMPT,MAAM,IAAIS,CAAC,GAAGP,KANP;AAAA;AAAA;AAAA;;AAOZV,YAAAA,IAAI,CAACkB,IAAL,CAAUV,MAAM,CAACW,KAAjB;AACAF,YAAAA,CAAC,IAAI,CAAL;AARY;AAAA,mBASGT,MAAM,YAAN,EATH;;AAAA;AASZA,YAAAA,MATY;AAAA;AAAA;;AAAA;AAAA,8CAYPR,IAZO;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAH;;AAAA,kBAAPS,OAAO;AAAA;AAAA;AAAA,GAAb","sourcesContent":["import { IDBPCursorWithValue, IDBPDatabase } from \"idb\";\r\nimport { MangoQuery } from \"rxdb/dist/types/types\";\r\nimport { translateMangoQuerySelector } from \".\";\r\nimport { getDbMeta } from \"./db-meta-helpers\";\r\nimport { generateKeyRange } from \"./idb-key-range\";\r\nconst { filterInMemoryFields } = require(\"pouchdb-selector-core\");\r\n\r\nexport const find = async <RxDocType>(\r\n  db: IDBPDatabase<unknown>,\r\n  collectionName: string,\r\n  query: MangoQuery<RxDocType>\r\n) => {\r\n  const metaDB = await getDbMeta();\r\n  const indexedCols = await metaDB.getAllFromIndex(\r\n    \"indexedCols\",\r\n    \"dbNameCollection\",\r\n    IDBKeyRange.bound([db.name, collectionName], [db.name, collectionName])\r\n  );\r\n  const translatedSelector = translateMangoQuerySelector(query, indexedCols);\r\n\r\n  let rows = [];\r\n  const store = db.transaction(collectionName).store;\r\n  if (translatedSelector.field && translatedSelector.queryOpts) {\r\n    const keyRange = generateKeyRange(translatedSelector.queryOpts);\r\n    const index = store.index(translatedSelector.field);\r\n    const cursor = await index.openCursor(keyRange); // sort\r\n    rows = await getRows(cursor, query.limit);\r\n  } else {\r\n    const cursor = await store.openCursor();\r\n    rows = await getRows(cursor, query.limit);\r\n  }\r\n\r\n  if (translatedSelector.inMemoryFields.length) {\r\n    rows = filterInMemoryFields(\r\n      rows.map((row) => {\r\n        // make data compatible with filterInMemoryFields\r\n        // TODO: copy and change this util\r\n        return { doc: row };\r\n      }),\r\n      query,\r\n      translatedSelector.inMemoryFields\r\n    );\r\n  }\r\n\r\n  return rows;\r\n};\r\n\r\nconst getRows = async (\r\n  cursor: IDBPCursorWithValue | null,\r\n  limit = Infinity\r\n) => {\r\n  const rows = [];\r\n  let i = 0;\r\n  while (cursor && i < limit) {\r\n    rows.push(cursor.value);\r\n    i += 1;\r\n    cursor = await cursor.continue();\r\n  }\r\n\r\n  return rows;\r\n};\r\n"],"file":"find.js"}