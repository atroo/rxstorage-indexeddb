{"version":3,"sources":["../../src/find.ts"],"names":["require","filterInMemoryFields","find","db","collectionName","query","metaDB","get","name","indexesMeta","indexedCols","indexes","pouchKeyRangeData","store","transaction","field","queryOpts","notIndexed","keyRange","index","results","console","log","openCursor","cursor","getRows","rows","map","row","doc","inMemoryFields","limit","Infinity","i","push","value"],"mappings":"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","sourcesContent":["import { IDBPCursorWithValue, IDBPDatabase } from \"idb\";\r\nimport { MangoQuery } from \"rxdb/dist/types/types\";\r\nimport { getDbMeta } from \"./db-meta-helpers\";\r\nimport { generateKeyRange } from \"./idb-key-range\";\r\nimport { generatePouchKeyRange } from \"./pouch-key-range\";\r\nconst { filterInMemoryFields } = require(\"pouchdb-selector-core\");\r\n\r\n// TODO: types\r\n\r\nexport const find = async <RxDocType>(\r\n  db: IDBPDatabase<unknown>,\r\n  collectionName: string,\r\n  query: MangoQuery<RxDocType>\r\n) => {\r\n  const metaDB = await getDbMeta();\r\n  const indexesMeta = await metaDB.get(\"indexedCols\", [\r\n    db.name,\r\n    collectionName,\r\n  ]);\r\n\r\n  const indexedCols = indexesMeta ? indexesMeta.indexes : [];\r\n  const pouchKeyRangeData = generatePouchKeyRange(query, indexedCols);\r\n\r\n  const store = db.transaction(collectionName, \"readonly\").store;\r\n  let cursor: IDBPCursorWithValue<\r\n    unknown,\r\n    ArrayLike<any>,\r\n    string,\r\n    unknown,\r\n    \"readonly\"\r\n  > | null;\r\n  if (\r\n    pouchKeyRangeData.field &&\r\n    pouchKeyRangeData.queryOpts &&\r\n    !pouchKeyRangeData.notIndexed\r\n  ) {\r\n    const keyRange = generateKeyRange(pouchKeyRangeData.queryOpts);\r\n    const index = store.index(pouchKeyRangeData.field);\r\n    const results = await index.get(keyRange);\r\n    console.log(\"RESULTS\", results);\r\n    cursor = await index.openCursor(keyRange);\r\n  } else {\r\n    cursor = await store.openCursor();\r\n  }\r\n\r\n  let rows = await getRows(cursor);\r\n\r\n  /**\r\n   * Filter in Memory Fields will take care of sort, limit and skip.\r\n   * TODO: if there's indexed field, then use IDBKeyRange to sort data.\r\n   */\r\n\r\n  rows = filterInMemoryFields(\r\n    rows.map((row) => {\r\n      // make data compatible with filterInMemoryFields\r\n      // TODO: fork \"pouchdb-selector-core\" and adapt lib for our uses case.\r\n      return { doc: row };\r\n    }),\r\n    query,\r\n    pouchKeyRangeData.inMemoryFields\r\n  );\r\n  console.log(\"FIND ROWS\", rows);\r\n  return rows.map((row) => {\r\n    return row.doc;\r\n  });\r\n};\r\n\r\nconst getRows = async (\r\n  cursor: IDBPCursorWithValue | null,\r\n  limit = Infinity\r\n) => {\r\n  const rows = [];\r\n  let i = 0;\r\n  while (cursor && i < limit) {\r\n    rows.push(cursor.value);\r\n    i += 1;\r\n    cursor = await cursor.continue();\r\n  }\r\n\r\n  return rows;\r\n};\r\n"],"file":"find.js"}