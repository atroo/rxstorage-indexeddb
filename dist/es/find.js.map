{"version":3,"sources":["../../src/find.ts"],"names":["require","filterInMemoryFields","find","db","collectionName","query","collName","console","log","indexesMetaStore","transaction","store","indexNameIndex","index","INDEXES_META_PRIMARY_KEY","indexesMeta","openCursor","indexesMetaCursor","push","value","translatedSelector","firstIndexedField","fields","opts","startkey","queryOpts","undefined","endkey","inclusive_start","inclusive_end","keyRange","cursor","rows","key","length","inMemoryFields","slice"],"mappings":"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","sourcesContent":["import { IDBPDatabase } from \"idb\";\r\nimport { MangoQuery } from \"rxdb/dist/types/types\";\r\nimport { translateMangoQuerySelector } from \".\";\r\nimport { getIndexesMetaCollName, INDEXES_META_PRIMARY_KEY } from \"./db-helpers\";\r\nimport { generateKeyRange } from \"./idb-key-range\";\r\nimport { IIdbKeyRangeOptions, IIndex } from \"./types/translate-mango-query\";\r\nconst { filterInMemoryFields } = require(\"pouchdb-selector-core\");\r\n\r\nexport const find = async <RxDocType>(\r\n  db: IDBPDatabase<unknown>,\r\n  collectionName: string,\r\n  query: MangoQuery<RxDocType>\r\n) => {\r\n  const collName = getIndexesMetaCollName(collectionName);\r\n  console.log(\"COLL NAME: \", collName);\r\n  const indexesMetaStore = db.transaction(\r\n    getIndexesMetaCollName(collectionName)\r\n  ).store;\r\n\r\n  const indexNameIndex = indexesMetaStore.index(INDEXES_META_PRIMARY_KEY);\r\n  const indexesMeta: IIndex[] = [];\r\n  let indexesMetaCursor = await indexNameIndex.openCursor();\r\n  while (indexesMetaCursor) {\r\n    indexesMeta.push(indexesMetaCursor.value);\r\n    indexesMetaCursor = await indexesMetaCursor.continue();\r\n  }\r\n\r\n  console.log(\"indexesMeta:\", indexesMeta);\r\n\r\n  const translatedSelector = translateMangoQuerySelector(query);\r\n\r\n  // TODO: use indexed field to generate opts\r\n  const firstIndexedField = translatedSelector.fields[0]; // TODO: can be undefined?\r\n  const opts: IIdbKeyRangeOptions = {\r\n    startkey: translatedSelector.queryOpts.startkey\r\n      ? translatedSelector.queryOpts.startkey[0]\r\n      : undefined,\r\n    endkey: translatedSelector.queryOpts.endkey\r\n      ? translatedSelector.queryOpts.endkey[0]\r\n      : undefined,\r\n    inclusive_start: translatedSelector.queryOpts.inclusive_start,\r\n    inclusive_end: translatedSelector.queryOpts.inclusive_end,\r\n  };\r\n\r\n  const keyRange = generateKeyRange(opts);\r\n\r\n  const store = db.transaction(collectionName, \"readwrite\").store;\r\n  const index = store.index(firstIndexedField);\r\n  let cursor = await index.openCursor(keyRange);\r\n\r\n  let rows = [];\r\n  while (cursor) {\r\n    const key = cursor.key;\r\n    const value = cursor.value;\r\n    rows.push(value);\r\n    cursor = await cursor.continue();\r\n  }\r\n\r\n  // TODO: currently that there should be single indexed key.\r\n  // And everything else should be in memory fields.\r\n  if (translatedSelector.fields.length > 1) {\r\n    const inMemoryFields = translatedSelector.fields.slice(1);\r\n    rows = filterInMemoryFields(rows, query, inMemoryFields);\r\n  }\r\n\r\n  return rows;\r\n};\r\n"],"file":"find.js"}