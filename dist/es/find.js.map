{"version":3,"sources":["../../src/find.ts"],"names":["require","filterInMemoryFields","find","db","collectionName","query","metaDB","getAllFromIndex","IDBKeyRange","bound","name","indexedCols","console","log","translatedSelector","firstIndexedField","fields","opts","startkey","queryOpts","undefined","endkey","inclusive_start","inclusive_end","keyRange","store","transaction","index","openCursor","cursor","rows","key","value","push","length","inMemoryFields","slice"],"mappings":";;;;;;;;;;;;;AAEA;;AACA;;AACA;;AAEA,eAAiCA,OAAO,CAAC,uBAAD,CAAxC;AAAA,IAAQC,oBAAR,YAAQA,oBAAR;;AAEO,IAAMC,IAAI;AAAA,2FAAG,iBAClBC,EADkB,EAElBC,cAFkB,EAGlBC,KAHkB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAKG,+BALH;;AAAA;AAKZC,YAAAA,MALY;AAAA;AAAA,mBAMQA,MAAM,CAACC,eAAP,CACxB,aADwB,EAExB,kBAFwB,EAGxBC,WAAW,CAACC,KAAZ,CAAkB,CAACN,EAAE,CAACO,IAAJ,EAAUN,cAAV,CAAlB,EAA6C,CAACD,EAAE,CAACO,IAAJ,EAAUN,cAAV,CAA7C,CAHwB,CANR;;AAAA;AAMZO,YAAAA,WANY;AAWlBC,YAAAA,OAAO,CAACC,GAAR,CAAY,cAAZ,EAA4BF,WAA5B;AAEMG,YAAAA,kBAbY,GAaS,mCAA4BT,KAA5B,CAbT,EAelB;;AACMU,YAAAA,iBAhBY,GAgBQD,kBAAkB,CAACE,MAAnB,CAA0B,CAA1B,CAhBR,EAgBsC;;AAClDC,YAAAA,IAjBY,GAiBgB;AAChCC,cAAAA,QAAQ,EAAEJ,kBAAkB,CAACK,SAAnB,CAA6BD,QAA7B,GACNJ,kBAAkB,CAACK,SAAnB,CAA6BD,QAA7B,CAAsC,CAAtC,CADM,GAENE,SAH4B;AAIhCC,cAAAA,MAAM,EAAEP,kBAAkB,CAACK,SAAnB,CAA6BE,MAA7B,GACJP,kBAAkB,CAACK,SAAnB,CAA6BE,MAA7B,CAAoC,CAApC,CADI,GAEJD,SAN4B;AAOhCE,cAAAA,eAAe,EAAER,kBAAkB,CAACK,SAAnB,CAA6BG,eAPd;AAQhCC,cAAAA,aAAa,EAAET,kBAAkB,CAACK,SAAnB,CAA6BI;AARZ,aAjBhB;AA4BZC,YAAAA,QA5BY,GA4BD,mCAAiBP,IAAjB,CA5BC;AA8BZQ,YAAAA,KA9BY,GA8BJtB,EAAE,CAACuB,WAAH,CAAetB,cAAf,EAA+B,WAA/B,EAA4CqB,KA9BxC;AA+BZE,YAAAA,KA/BY,GA+BJF,KAAK,CAACE,KAAN,CAAYZ,iBAAZ,CA/BI;AAAA;AAAA,mBAgCCY,KAAK,CAACC,UAAN,CAAiBJ,QAAjB,CAhCD;;AAAA;AAgCdK,YAAAA,MAhCc;AAkCdC,YAAAA,IAlCc,GAkCP,EAlCO;;AAAA;AAAA,iBAmCXD,MAnCW;AAAA;AAAA;AAAA;;AAoCVE,YAAAA,GApCU,GAoCJF,MAAM,CAACE,GApCH;AAqCVC,YAAAA,KArCU,GAqCFH,MAAM,CAACG,KArCL;AAsChBpB,YAAAA,OAAO,CAACC,GAAR,CAAY,YAAZ,EAA0BkB,GAA1B;AACAnB,YAAAA,OAAO,CAACC,GAAR,CAAY,YAAZ;AACAiB,YAAAA,IAAI,CAACG,IAAL,CAAUD,KAAV;AAxCgB;AAAA,mBAyCDH,MAAM,YAAN,EAzCC;;AAAA;AAyChBA,YAAAA,MAzCgB;AAAA;AAAA;;AAAA;AA4ClB;AACA;AACA,gBAAIf,kBAAkB,CAACE,MAAnB,CAA0BkB,MAA1B,GAAmC,CAAvC,EAA0C;AAClCC,cAAAA,cADkC,GACjBrB,kBAAkB,CAACE,MAAnB,CAA0BoB,KAA1B,CAAgC,CAAhC,CADiB;AAExCN,cAAAA,IAAI,GAAG7B,oBAAoB,CAAC6B,IAAD,EAAOzB,KAAP,EAAc8B,cAAd,CAA3B;AACD;;AAjDiB,6CAmDXL,IAnDW;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAH;;AAAA,kBAAJ5B,IAAI;AAAA;AAAA;AAAA,GAAV","sourcesContent":["import { IDBPDatabase } from \"idb\";\r\nimport { MangoQuery } from \"rxdb/dist/types/types\";\r\nimport { translateMangoQuerySelector } from \".\";\r\nimport { getDbMeta } from \"./db-meta-helpers\";\r\nimport { generateKeyRange } from \"./idb-key-range\";\r\nimport { IIdbKeyRangeOptions, IIndex } from \"./types/translate-mango-query\";\r\nconst { filterInMemoryFields } = require(\"pouchdb-selector-core\");\r\n\r\nexport const find = async <RxDocType>(\r\n  db: IDBPDatabase<unknown>,\r\n  collectionName: string,\r\n  query: MangoQuery<RxDocType>\r\n) => {\r\n  const metaDB = await getDbMeta();\r\n  const indexedCols = await metaDB.getAllFromIndex(\r\n    \"indexedCols\",\r\n    \"dbNameCollection\",\r\n    IDBKeyRange.bound([db.name, collectionName], [db.name, collectionName])\r\n  );\r\n  console.log(\"indexesMeta:\", indexedCols);\r\n\r\n  const translatedSelector = translateMangoQuerySelector(query);\r\n\r\n  // TODO: use indexed field to generate opts\r\n  const firstIndexedField = translatedSelector.fields[0]; // TODO: can be undefined?\r\n  const opts: IIdbKeyRangeOptions = {\r\n    startkey: translatedSelector.queryOpts.startkey\r\n      ? translatedSelector.queryOpts.startkey[0]\r\n      : undefined,\r\n    endkey: translatedSelector.queryOpts.endkey\r\n      ? translatedSelector.queryOpts.endkey[0]\r\n      : undefined,\r\n    inclusive_start: translatedSelector.queryOpts.inclusive_start,\r\n    inclusive_end: translatedSelector.queryOpts.inclusive_end,\r\n  };\r\n\r\n  const keyRange = generateKeyRange(opts);\r\n\r\n  const store = db.transaction(collectionName, \"readwrite\").store;\r\n  const index = store.index(firstIndexedField);\r\n  let cursor = await index.openCursor(keyRange);\r\n\r\n  let rows = [];\r\n  while (cursor) {\r\n    const key = cursor.key;\r\n    const value = cursor.value;\r\n    console.log(\"FIND KEy: \", key);\r\n    console.log(\"FIND val: \");\r\n    rows.push(value);\r\n    cursor = await cursor.continue();\r\n  }\r\n\r\n  // TODO: currently that there should be single indexed key.\r\n  // And everything else should be in memory fields.\r\n  if (translatedSelector.fields.length > 1) {\r\n    const inMemoryFields = translatedSelector.fields.slice(1);\r\n    rows = filterInMemoryFields(rows, query, inMemoryFields);\r\n  }\r\n\r\n  return rows;\r\n};\r\n"],"file":"find.js"}