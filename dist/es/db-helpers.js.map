{"version":3,"sources":["../../src/db-helpers.ts"],"names":["CHANGES_COLLECTION_SUFFIX","IDB_DATABASE_STATE_BY_NAME","Map","getChangesCollName","collName","genIndexName","index","Array","isArray","join","lock","AsyncLock","createIdbDatabase","settings","metaDB","dbState","get","databaseName","metaData","reqMetaData","version","collections","dbName","updateNeeded","foundCol","find","col","name","collectionName","indexes","schema","forEach","idx","push","newCollections","changesCollectionName","primaryPath","newDbState","getDb","deleteCollections","acquire","dataBaseState","getDatabaseState","length","db","upgrade","collectionData","store","createObjectStore","keyPath","createIndex","colName","deleteObjectStore","blocking","idbSettings","close","terminated","indexedColsStore","transaction","collData","reqIndexesMeta","indexesMeta","collection","value","primary","put","metaDataCollections","concat","map","coll","filter","indexOf","locked","undefined","set","removeCollection","getPrimaryFieldOfPrimaryKey","primaryKey","key","newRxError","code","parameters","RxError","overwritable","tunnelErrorMessage","Error"],"mappings":"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","sourcesContent":["import { deleteDB, IDBPDatabase, openDB } from \"idb\";\r\nimport { overwritable, RxJsonSchema } from \"rxdb\";\r\nimport {\r\n  CompositePrimaryKey,\r\n  PrimaryKey,\r\n  RxErrorKey,\r\n  RxErrorParameters,\r\n} from \"rxdb/dist/types/types\";\r\nimport {\r\n  BrowserStorageState,\r\n  IMetaDB,\r\n  Index,\r\n} from \"./types/browser-storeage-state\";\r\nimport { RxError } from \"./rx-error\";\r\nimport { getDbMeta } from \"./db-meta-helpers\";\r\nimport { validateIndexValues } from \"./utils\";\r\nimport AsyncLock from \"async-lock\";\r\nimport { IdbSettings } from \"./types\";\r\n\r\nexport const CHANGES_COLLECTION_SUFFIX = \"-rxdb-changes\";\r\n\r\nexport const IDB_DATABASE_STATE_BY_NAME: Map<string, BrowserStorageState> =\r\n  new Map();\r\n\r\nexport const getChangesCollName = (collName: string) => {\r\n  return collName + CHANGES_COLLECTION_SUFFIX;\r\n};\r\n\r\nexport const genIndexName = (index: string | string[]) => {\r\n  if (Array.isArray(index)) {\r\n    return index.join(\".\");\r\n  }\r\n\r\n  return index;\r\n};\r\n\r\nconst lock = new AsyncLock();\r\n\r\n/**\r\n * Can be called several times for the same db\r\n * Save all new collections data in map and run migration once db requessted (getDb)\r\n *\r\n * @param databaseName\r\n * @param collectionName\r\n * @param primaryPath\r\n * @param schema\r\n * @returns\r\n */\r\n\r\nexport const createIdbDatabase = async <RxDocType>(settings: {\r\n  databaseName: string;\r\n  collectionName: string;\r\n  primaryPath: string;\r\n  schema: Pick<RxJsonSchema<RxDocType>, \"indexes\" | \"version\">;\r\n  idbSettings: IdbSettings;\r\n}) => {\r\n  const metaDB = await getDbMeta();\r\n  let metaData: BrowserStorageState[\"metaData\"];\r\n  const dbState = IDB_DATABASE_STATE_BY_NAME.get(settings.databaseName);\r\n  if (dbState?.metaData) {\r\n    metaData = dbState.metaData;\r\n  } else {\r\n    // Store \"version\" data in seperate db to properly handle indexeddb version update.\r\n    const reqMetaData = await metaDB.get(\"dbMetaData\", settings.databaseName);\r\n    if (reqMetaData) {\r\n      metaData = reqMetaData;\r\n    } else {\r\n      metaData = {\r\n        version: 0,\r\n        collections: [],\r\n        dbName: settings.databaseName,\r\n      };\r\n    }\r\n  }\r\n\r\n  let updateNeeded = true;\r\n  const foundCol = metaData.collections.find(\r\n    (col) => col.name === settings.collectionName\r\n  );\r\n  if (foundCol) {\r\n    updateNeeded = false;\r\n  }\r\n\r\n  const indexes: Array<string | string[]> = [];\r\n  if (settings.schema.indexes) {\r\n    settings.schema.indexes.forEach((idx) => {\r\n      if (!validateIndexValues(idx)) {\r\n        return;\r\n      }\r\n\r\n      indexes.push(idx as string | string[]);\r\n    });\r\n  }\r\n\r\n  const newCollections: BrowserStorageState[\"newCollections\"] = [];\r\n  const changesCollectionName = getChangesCollName(settings.collectionName);\r\n\r\n  if (updateNeeded) {\r\n    newCollections.push({\r\n      collectionName: settings.collectionName,\r\n      primaryPath: settings.primaryPath,\r\n      indexes,\r\n      version: settings.schema.version,\r\n    });\r\n\r\n    newCollections.push({\r\n      collectionName: changesCollectionName,\r\n      primaryPath: \"eventId\",\r\n      indexes: [\"sequence\"],\r\n      version: 1,\r\n    });\r\n  }\r\n\r\n  const newDbState: BrowserStorageState = {\r\n    ...dbState,\r\n    getDb: async (deleteCollections: string[] = []) => {\r\n      // lock db request.\r\n      // without lock somebody else can request database while idb update is still running.\r\n      // this will lead to unexpected results\r\n      return lock.acquire(settings.databaseName, async () => {\r\n        const dataBaseState = getDatabaseState(settings.databaseName);\r\n\r\n        const newCollections = dataBaseState.newCollections;\r\n        const updateNeeded =\r\n          newCollections.length > 0 || deleteCollections.length > 0;\r\n\r\n        if (!updateNeeded && dataBaseState.db) {\r\n          return dataBaseState.db;\r\n        }\r\n\r\n        const metaData = dataBaseState.metaData;\r\n        if (updateNeeded) {\r\n          metaData.version += 1;\r\n        }\r\n\r\n        const db = await openDB(settings.databaseName, metaData.version, {\r\n          upgrade(db) {\r\n            for (const collectionData of newCollections) {\r\n              const store = db.createObjectStore(\r\n                collectionData.collectionName,\r\n                {\r\n                  keyPath: collectionData.primaryPath,\r\n                }\r\n              );\r\n\r\n              collectionData.indexes.forEach((index) => {\r\n                store.createIndex(genIndexName(index), index);\r\n              });\r\n            }\r\n\r\n            for (const colName of deleteCollections) {\r\n              db.deleteObjectStore(colName);\r\n            }\r\n          },\r\n          blocking() {\r\n            // Make sure to add a handler to be notified if another page requests a version\r\n            // change. We must close the database. This allows the other page to upgrade the database.\r\n            // If you don't do this then the upgrade won't happen until the user closes the tab.\r\n            //\r\n            settings.idbSettings.blocking?.();\r\n            db.close();\r\n          },\r\n          terminated() {},\r\n        });\r\n\r\n        /**\r\n         * Store meta data about indexes\r\n         * Use it later to understand what index to use to query data\r\n         *\r\n         */\r\n        if (newCollections.length) {\r\n          const indexedColsStore = metaDB.transaction(\r\n            \"indexedCols\",\r\n            \"readwrite\"\r\n          ).store;\r\n\r\n          for (const collData of newCollections) {\r\n            const reqIndexesMeta = await indexedColsStore.get([\r\n              settings.databaseName,\r\n              collData.collectionName,\r\n            ]);\r\n            const indexesMeta: IMetaDB[\"indexedCols\"][\"value\"] = reqIndexesMeta\r\n              ? reqIndexesMeta\r\n              : {\r\n                  dbName: settings.databaseName,\r\n                  collection: collData.collectionName,\r\n                  indexes: [],\r\n                };\r\n\r\n            const indexes = collData.indexes;\r\n            indexes.forEach((index) => {\r\n              indexesMeta.indexes.push({\r\n                name: genIndexName(index),\r\n                value: index,\r\n              });\r\n            });\r\n            // primary also can be counted as indexedData, but it should be handled differently.\r\n            // use \"primary to dect that it is actually \"primary\" field.\r\n            indexesMeta.indexes.push({\r\n              name: collData.primaryPath,\r\n              value: collData.primaryPath,\r\n              primary: true,\r\n            });\r\n\r\n            indexedColsStore.put(indexesMeta);\r\n          }\r\n        }\r\n\r\n        let metaDataCollections = metaData.collections.concat(\r\n          newCollections.map((coll) => {\r\n            return { name: coll.collectionName, version: coll.version };\r\n          })\r\n        );\r\n\r\n        /**\r\n         * exclude deleted collections from meta.\r\n         */\r\n        if (deleteCollections) {\r\n          metaDataCollections = metaDataCollections.filter((coll) => {\r\n            return deleteCollections.indexOf(coll.name) === -1;\r\n          });\r\n\r\n          for (const colName of deleteCollections) {\r\n            /**\r\n             * also delete indexes meta along with store. they're not needed anymore\r\n             * DO NOT do this via \"upgrade\" callback as upgrade transaction can be finish while\r\n             * indexes meta being removed\r\n             */\r\n            await metaDB.delete(\"indexedCols\", [\r\n              settings.databaseName,\r\n              colName,\r\n            ]);\r\n          }\r\n        }\r\n\r\n        // transaction went successfully. clear \"newCollections\"\r\n        const newDbState: BrowserStorageState = {\r\n          ...dataBaseState,\r\n          db,\r\n          newCollections: [],\r\n          metaData: {\r\n            ...dataBaseState.metaData,\r\n            collections: metaDataCollections,\r\n          },\r\n          locked: undefined,\r\n        };\r\n\r\n        await metaDB.put(\"dbMetaData\", newDbState.metaData);\r\n        IDB_DATABASE_STATE_BY_NAME.set(settings.databaseName, newDbState);\r\n\r\n        return db;\r\n      });\r\n    },\r\n    removeCollection: async () => {\r\n      const dataBaseState = getDatabaseState(settings.databaseName);\r\n      return dataBaseState.getDb([\r\n        settings.collectionName,\r\n        getChangesCollName(settings.collectionName),\r\n      ]);\r\n    },\r\n    metaData,\r\n    newCollections: [\r\n      ...(dbState ? dbState.newCollections : []),\r\n      ...newCollections,\r\n    ],\r\n  };\r\n\r\n  IDB_DATABASE_STATE_BY_NAME.set(settings.databaseName, newDbState);\r\n\r\n  return newDbState;\r\n};\r\n\r\nexport function getPrimaryFieldOfPrimaryKey<RxDocType>(\r\n  primaryKey: PrimaryKey<RxDocType>\r\n): string {\r\n  if (typeof primaryKey === \"string\") {\r\n    return primaryKey;\r\n  } else {\r\n    return (primaryKey as CompositePrimaryKey<RxDocType>).key as string;\r\n  }\r\n}\r\n\r\nexport function newRxError(\r\n  code: RxErrorKey,\r\n  parameters?: RxErrorParameters\r\n): RxError {\r\n  return new RxError(code, overwritable.tunnelErrorMessage(code), parameters);\r\n}\r\n\r\nexport const getDatabaseState = (databaseName: string) => {\r\n  const dataBaseState = IDB_DATABASE_STATE_BY_NAME.get(databaseName);\r\n  if (!dataBaseState) {\r\n    throw new Error(\"dataBase state is undefined\");\r\n  }\r\n\r\n  return dataBaseState;\r\n};\r\n"],"file":"db-helpers.js"}