{"version":3,"sources":["../../src/idb-key-range.ts"],"names":["IDB_NULL","Number","MIN_SAFE_INTEGER","IDB_FALSE","IDB_TRUE","IDB_COLLATE_LO","NEGATIVE_INFINITY","IDB_COLLATE_HI","generateKeyRange","opts","defined","obj","k","convert","key","exact","filterDeleted","map","COUCH_COLLATE_LO","hasOwnProperty","COUCH_COLLATE_HI","inclusive_end","inclusive_start","descending","realEndkey","startkey","realInclusiveEnd","endkey","IDBKeyRange","only","lowerBound","upperBound","bound","err","console","error","Error","JSON","stringify"],"mappings":"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","sourcesContent":["import { EndKey, IIdbKeyRangeOptions, StartKey } from \"./types/pouch-key-range\";\r\nimport {\r\n  COLLATE_LO as COUCH_COLLATE_LO,\r\n  COLLATE_HI as COUCH_COLLATE_HI,\r\n} from \"./variables\";\r\n\r\nvar IDB_NULL = Number.MIN_SAFE_INTEGER;\r\nvar IDB_FALSE = Number.MIN_SAFE_INTEGER + 1;\r\nvar IDB_TRUE = Number.MIN_SAFE_INTEGER + 2;\r\n\r\n// From pouch indexeddb adapter\r\n\r\n// Adapted from: https://www.w3.org/TR/IndexedDB/#compare-two-keys\r\n// Importantly, *there is no upper bound possible* in idb. The ideal data\r\n// structure an infintely deep array:\r\n//   var IDB_COLLATE_HI = []; IDB_COLLATE_HI.push(IDB_COLLATE_HI)\r\n// But IDBKeyRange is not a fan of shenanigans, so I've just gone with 12 layers\r\n// because it looks nice and surely that's enough!\r\nvar IDB_COLLATE_LO = Number.NEGATIVE_INFINITY;\r\nvar IDB_COLLATE_HI = [[[[[[[[[[[[]]]]]]]]]]]];\r\n\r\n// TODO: create type for opts\r\nexport const generateKeyRange = (opts: IIdbKeyRangeOptions) => {\r\n  function defined(obj: any, k: string) {\r\n    return obj[k] !== void 0;\r\n  }\r\n\r\n  // Converts a valid CouchDB key into a valid IndexedDB one\r\n  function convert(key: any, exact?: boolean) {\r\n    // The first item in every native index is doc.deleted, and we always want\r\n    // to only search documents that are not deleted.\r\n    // \"foo\" -> [0, \"foo\"]\r\n    // var filterDeleted = [0].concat(key);\r\n\r\n    const filterDeleted = key;\r\n\r\n    return filterDeleted.map(function (k: any) {\r\n      // null, true and false are not indexable by indexeddb. When we write\r\n      // these values we convert them to these constants, and so when we\r\n      // query for them we need to convert the query also.\r\n      if (k === null && exact) {\r\n        // for non-exact queries we treat null as a collate property\r\n        // see `if (!exact)` block below\r\n        return IDB_NULL;\r\n      } else if (k === true) {\r\n        return IDB_TRUE;\r\n      } else if (k === false) {\r\n        return IDB_FALSE;\r\n      }\r\n\r\n      if (!exact) {\r\n        // We get passed CouchDB's collate low and high values, so for non-exact\r\n        // ranged queries we're going to convert them to our IDB equivalents\r\n        if (k === COUCH_COLLATE_LO) {\r\n          return IDB_COLLATE_LO;\r\n        } else if (k.hasOwnProperty(COUCH_COLLATE_HI)) {\r\n          return IDB_COLLATE_HI;\r\n        }\r\n      }\r\n\r\n      return k;\r\n    });\r\n  }\r\n\r\n  // CouchDB and so PouchdB defaults to true. We need to make this explicit as\r\n  // we invert these later for IndexedDB.\r\n  if (!defined(opts, \"inclusive_end\")) {\r\n    opts.inclusive_end = true;\r\n  }\r\n  if (!defined(opts, \"inclusive_start\")) {\r\n    opts.inclusive_start = true;\r\n  }\r\n\r\n  if (opts.descending) {\r\n    // Flip before generating. We'll check descending again later when performing\r\n    // an index request\r\n    var realEndkey = opts.startkey,\r\n      realInclusiveEnd = opts.inclusive_start;\r\n\r\n    opts.startkey = opts.endkey;\r\n    opts.endkey = realEndkey as EndKey | StartKey;\r\n    opts.inclusive_start = opts.inclusive_end;\r\n    opts.inclusive_end = realInclusiveEnd;\r\n  }\r\n\r\n  try {\r\n    if (defined(opts, \"key\")) {\r\n      return IDBKeyRange.only(convert(opts.key, true));\r\n    }\r\n\r\n    if (defined(opts, \"startkey\") && !defined(opts, \"endkey\")) {\r\n      return IDBKeyRange.lowerBound(\r\n        convert(opts.startkey),\r\n        !opts.inclusive_start\r\n      );\r\n    }\r\n\r\n    if (!defined(opts, \"startkey\") && defined(opts, \"endkey\")) {\r\n      return IDBKeyRange.upperBound(convert(opts.endkey), !opts.inclusive_end);\r\n    }\r\n\r\n    if (defined(opts, \"startkey\") && defined(opts, \"endkey\")) {\r\n      return IDBKeyRange.bound(\r\n        convert(opts.startkey),\r\n        convert(opts.endkey),\r\n        !opts.inclusive_start,\r\n        !opts.inclusive_end\r\n      );\r\n    }\r\n\r\n    return IDBKeyRange.only([0]);\r\n  } catch (err) {\r\n    console.error(\"Could not generate keyRange\", err, opts);\r\n    throw Error(\"Could not generate key range with \" + JSON.stringify(opts));\r\n  }\r\n};\r\n"],"file":"idb-key-range.js"}