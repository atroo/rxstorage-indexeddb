{"version":3,"sources":["../../src/idb-key-range.ts"],"names":["COUCH_COLLATE_HI","IDB_NULL","Number","MIN_SAFE_INTEGER","IDB_FALSE","IDB_TRUE","IDB_COLLATE_LO","NEGATIVE_INFINITY","IDB_COLLATE_HI","generateKeyRange","opts","defined","obj","k","inclusiveEnd","inclusiveStart","descending","realEndkey","startkey","realInclusiveEnd","endkey","IDBKeyRange","lowerBound","convertKeys","upperBound","bound","only","err","console","error","Error","JSON","stringify","convertKey","exact","COUCH_COLLATE_LO","hasOwnProperty","keys","length","map"],"mappings":"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","sourcesContent":["import { EndKey, IIdbKeyRangeOptions, StartKey } from \"./types/pouch-key-range\";\r\nimport { COLLATE_LO as COUCH_COLLATE_LO } from \"./variables\";\r\nconst COUCH_COLLATE_HI = \"\\uffff\"; // actually used as {\"\\uffff\": {}}\r\n\r\nvar IDB_NULL = Number.MIN_SAFE_INTEGER;\r\nvar IDB_FALSE = Number.MIN_SAFE_INTEGER + 1;\r\nvar IDB_TRUE = Number.MIN_SAFE_INTEGER + 2;\r\n\r\n// From pouch indexeddb adapter\r\n\r\n// Adapted from: https://www.w3.org/TR/IndexedDB/#compare-two-keys\r\n// Importantly, *there is no upper bound possible* in idb. The ideal data\r\n// structure an infintely deep array:\r\n//   var IDB_COLLATE_HI = []; IDB_COLLATE_HI.push(IDB_COLLATE_HI)\r\n// But IDBKeyRange is not a fan of shenanigans, so I've just gone with 12 layers\r\n// because it looks nice and surely that's enough!\r\nvar IDB_COLLATE_LO = Number.NEGATIVE_INFINITY;\r\nvar IDB_COLLATE_HI = [[[[[[[[[[[[]]]]]]]]]]]];\r\n\r\n// TODO: create type for opts\r\nexport const generateKeyRange = (opts: IIdbKeyRangeOptions) => {\r\n  function defined(obj: any, k: string) {\r\n    return obj[k] !== void 0;\r\n  }\r\n\r\n  // CouchDB and so PouchdB defaults to true. We need to make this explicit as\r\n  // we invert these later for IndexedDB.\r\n  if (!defined(opts, \"inclusiveEnd\")) {\r\n    opts.inclusiveEnd = true;\r\n  }\r\n  if (!defined(opts, \"inclusiveStart\")) {\r\n    opts.inclusiveStart = true;\r\n  }\r\n\r\n  if (opts.descending) {\r\n    // Flip before generating. We'll check descending again later when performing\r\n    // an index request\r\n    var realEndkey = opts.startkey,\r\n      realInclusiveEnd = opts.inclusiveStart;\r\n\r\n    opts.startkey = opts.endkey;\r\n    opts.endkey = realEndkey;\r\n    opts.inclusiveStart = opts.inclusiveEnd;\r\n    opts.inclusiveEnd = realInclusiveEnd;\r\n  }\r\n\r\n  try {\r\n    if (defined(opts, \"startkey\") && !defined(opts, \"endkey\")) {\r\n      return IDBKeyRange.lowerBound(\r\n        convertKeys(opts.startkey),\r\n        !opts.inclusiveStart\r\n      );\r\n    }\r\n\r\n    if (!defined(opts, \"startkey\") && defined(opts, \"endkey\")) {\r\n      return IDBKeyRange.upperBound(\r\n        convertKeys(opts.endkey),\r\n        !opts.inclusiveEnd\r\n      );\r\n    }\r\n\r\n    if (defined(opts, \"startkey\") && defined(opts, \"endkey\")) {\r\n      return IDBKeyRange.bound(\r\n        convertKeys(opts.startkey),\r\n        convertKeys(opts.endkey),\r\n        !opts.inclusiveStart,\r\n        !opts.inclusiveEnd\r\n      );\r\n    }\r\n\r\n    return IDBKeyRange.only([0]);\r\n  } catch (err) {\r\n    console.error(\"Could not generate keyRange\", err, opts);\r\n    throw Error(\"Could not generate key range with \" + JSON.stringify(opts));\r\n  }\r\n};\r\n\r\nfunction convertKey(k: StartKey | EndKey | boolean, exact?: boolean) {\r\n  // null, true and false are not indexable by indexeddb. When we write\r\n  // these values we convert them to these constants, and so when we\r\n  // query for them we need to convert the query also.\r\n  if (k === null && exact) {\r\n    // for non-exact queries we treat null as a collate property\r\n    // see `if (!exact)` block below\r\n    return IDB_NULL;\r\n  } else if (k === true) {\r\n    return IDB_TRUE;\r\n  } else if (k === false) {\r\n    return IDB_FALSE;\r\n  }\r\n\r\n  if (!exact) {\r\n    // We get passed CouchDB's collate low and high values, so for non-exact\r\n    // ranged queries we're going to convert them to our IDB equivalents\r\n    if (k === COUCH_COLLATE_LO) {\r\n      return IDB_COLLATE_LO;\r\n    } else if (typeof k === \"object\" && k.hasOwnProperty(COUCH_COLLATE_HI)) {\r\n      return IDB_COLLATE_HI;\r\n    }\r\n  }\r\n\r\n  return k;\r\n}\r\n\r\n// Converts a valid CouchDB key into a valid IndexedDB one\r\nfunction convertKeys(\r\n  keys: Array<StartKey | EndKey | boolean>,\r\n  exact?: boolean\r\n) {\r\n  if (!keys.length) {\r\n    return keys;\r\n  }\r\n\r\n  // if (keys.length === 1) {\r\n  //   return convertKey(keys[0], exact);\r\n  // }\r\n\r\n  return keys.map((k) => convertKey(k, exact));\r\n}\r\n"],"file":"idb-key-range.js"}